<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="generator" content="Asciidoctor 0.1.4"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Clustering modes</title> <style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }
audio, canvas, video { display: inline-block; }
audio:not([controls]) { display: none; height: 0; }
[hidden] { display: none; }
html { background: #fff; color: #000; font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }
body { margin: 0; }
a:focus { outline: thin dotted; }
a:active, a:hover { outline: 0; }
h1 { font-size: 2em; margin: 0.67em 0; }
abbr[title] { border-bottom: 1px dotted; }
b, strong { font-weight: bold; }
dfn { font-style: italic; }
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }
mark { background: #ff0; color: #000; }
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }
pre { white-space: pre-wrap; }
q { quotes: "\201C" "\201D" "\2018" "\2019"; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }
img { border: 0; }
svg:not(:root) { overflow: hidden; }
figure { margin: 0; }
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }
legend { border: 0; padding: 0; }
button, input, select, textarea { font-family: inherit; font-size: 100%; margin: 0; }
button, input { line-height: normal; }
button, select { text-transform: none; }
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; cursor: pointer; }
button[disabled], html input[disabled] { cursor: default; }
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; padding: 0; }
input[type="search"] { -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; }
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
textarea { overflow: auto; vertical-align: top; }
table { border-collapse: collapse; border-spacing: 0; }
*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
html, body { font-size: 100%; }
body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }
a:hover { cursor: pointer; }
a:focus { outline: none; }
img, object, embed { max-width: 100%; height: auto; }
object, embed { height: 100%; }
img { -ms-interpolation-mode: bicubic; }
#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }
.left { float: left !important; }
.right { float: right !important; }
.text-left { text-align: left !important; }
.text-right { text-align: right !important; }
.text-center { text-align: center !important; }
.text-justify { text-align: justify !important; }
.hide { display: none; }
.antialiased, body { -webkit-font-smoothing: antialiased; }
img { display: inline-block; vertical-align: middle; }
textarea { height: auto; min-height: 50px; }
select { width: 100%; }
p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }
.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #7a2518; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }
a { color: #005498; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #00467f; }
a img { border: none; }
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Georgia, "URW Bookman L", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }
h1 { font-size: 2.125em; }
h2 { font-size: 1.6875em; }
h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }
h4 { font-size: 1.125em; }
h5 { font-size: 1.125em; }
h6 { font-size: 1em; }
hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }
em, i { font-style: italic; line-height: inherit; }
strong, b { font-weight: bold; line-height: inherit; }
small { font-size: 60%; line-height: inherit; }
code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #6d180b; }
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }
ul, ol { margin-left: 1.5em; }
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #222222; border-bottom: 1px dotted #dddddd; cursor: help; }
abbr { text-transform: none; }
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: inherit; color: #555555; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #555555; }
blockquote, blockquote p { line-height: 1.6; color: #6f6f6f; }
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }
.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }
@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
.print-only { display: none !important; }
@media print { * { background: transparent !important; color: #000 !important; box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }
.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }
*:not(pre) > code { font-size: 0.9375em; padding: 1px 3px 0; white-space: nowrap; background-color: #f2f2f2; border: 1px solid #cccccc; -webkit-border-radius: 4px; border-radius: 4px; text-shadow: none; }
pre, pre > code { line-height: 1.4; color: inherit; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }
kbd.keyseq { color: #555555; }
kbd:not(.keyseq) { display: inline-block; color: #222222; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }
kbd kbd:first-child { margin-left: 0; }
kbd kbd:last-child { margin-right: 0; }
.menuseq, .menu { color: #090909; }
p a > code:hover { color: #561309; }
#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }
#header { margin-bottom: 2.5em; }
#header > h1 { color: black; font-weight: normal; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #6f6f6f; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }
#toc { border-bottom: 3px double #ebebeb; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }
#toctitle { color: #7a2518; }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; }
  #toc.toc2 { position: fixed; width: 20em; left: 0; top: 0; border-right: 1px solid #ebebeb; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; }
  #toc.toc2 > ul { font-size: .95em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1.25em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #ebebeb; left: auto; right: 0; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }
#content #toctitle { font-weight: bold; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-size: 1em; padding-left: 0.125em; }
#footer { max-width: 100%; background-color: #222222; padding: 1.25em; }
#footer-text { color: #dddddd; line-height: 1.44; }
.sect1 { padding-bottom: 1.25em; }
.sect1 + .sect1 { border-top: 3px double #ebebeb; }
#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }
.imageblock, .literalblock, .listingblock, .verseblock, .videoblock { margin-bottom: 1.25em; }
.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }
.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }
table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }
.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #6f6f6f; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }
.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }
.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }
.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; line-height: 1.6; }
.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }
.literalblock > .content pre, .listingblock > .content pre { background: none; border-width: 1px 0; border-style: dotted; border-color: #bfbfbf; -webkit-border-radius: 4px; border-radius: 4px; padding: 0.75em 0.75em 0.5em 0.75em; word-wrap: break-word; }
.literalblock > .content pre.nowrap, .listingblock > .content pre.nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock > .content pre > code, .listingblock > .content pre > code { display: block; }
@media only screen { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.8em; } }
@media only screen and (min-width: 768px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.9em; } }
@media only screen and (min-width: 1280px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 1em; } }
.listingblock > .content { position: relative; }
.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }
.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }
.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }
.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }
table.pyhltable { border: 0; margin-bottom: 0; }
table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }
table.pyhltable td.code { padding-left: .75em; padding-right: 0; }
.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }
.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }
table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }
.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: inherit; color: #555555; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }
table thead th, table tfoot th { font-weight: bold; }
table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 4px; border-radius: 4px; border-top: 1px solid #dddddd; border-bottom: 1px solid #dddddd; }
table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }
table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }
table.tableblock td .paragraph:last-child p, table.tableblock td > p:last-child { margin-bottom: 0; }
th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }
th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }
th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }
th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }
th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }
th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }
p.tableblock.header { color: #222222; font-weight: bold; }
td > div.verse { white-space: pre; }
ol { margin-left: 1.75em; }
ul li ol { margin-left: 1.5em; }
dl dd { margin-left: 1.125em; }
dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }
ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }
ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }
ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }
ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }
ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }
ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }
.unstyled dl dt { font-weight: normal; font-style: normal; }
ol.arabic { list-style-type: decimal; }
ol.decimal { list-style-type: decimal-leading-zero; }
ol.loweralpha { list-style-type: lower-alpha; }
ol.upperalpha { list-style-type: upper-alpha; }
ol.lowerroman { list-style-type: lower-roman; }
ol.upperroman { list-style-type: upper-roman; }
ol.lowergreek { list-style-type: lower-greek; }
.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }
td.hdlist1 { padding-right: .8em; font-weight: bold; }
td.hdlist1, td.hdlist2 { vertical-align: top; }
.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }
.colist > table tr > td:first-of-type { padding: 0 .8em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }
.qanda > ol > li > p > em:only-child { color: #00467f; }
.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }
.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }
.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }
a.image { text-decoration: none; }
span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }
.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }
div.unbreakable { page-break-inside: avoid; }
.big { font-size: larger; }
.small { font-size: smaller; }
.underline { text-decoration: underline; }
.overline { text-decoration: overline; }
.line-through { text-decoration: line-through; }
.aqua { color: #00bfbf; }
.aqua-background { background-color: #00fafa; }
.black { color: black; }
.black-background { background-color: black; }
.blue { color: #0000bf; }
.blue-background { background-color: #0000fa; }
.fuchsia { color: #bf00bf; }
.fuchsia-background { background-color: #fa00fa; }
.gray { color: #606060; }
.gray-background { background-color: #7d7d7d; }
.green { color: #006000; }
.green-background { background-color: #007d00; }
.lime { color: #00bf00; }
.lime-background { background-color: #00fa00; }
.maroon { color: #600000; }
.maroon-background { background-color: #7d0000; }
.navy { color: #000060; }
.navy-background { background-color: #00007d; }
.olive { color: #606000; }
.olive-background { background-color: #7d7d00; }
.purple { color: #600060; }
.purple-background { background-color: #7d007d; }
.red { color: #bf0000; }
.red-background { background-color: #fa0000; }
.silver { color: #909090; }
.silver-background { background-color: #bcbcbc; }
.teal { color: #006060; }
.teal-background { background-color: #007d7d; }
.white { color: #bfbfbf; }
.white-background { background-color: #fafafa; }
.yellow { color: #bfbf00; }
.yellow-background { background-color: #fafa00; }
span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }
.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #005498; color: #003f72; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }
.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }
.literalblock > .content > pre, .listingblock > .content > pre { -webkit-border-radius: 0; border-radius: 0; }

</style> <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css"> <style>
/* Foundation stylesheet for CodeRay (to match GitHub theme) | MIT License | http://foundation.zurb.com */
table.CodeRay { border-collapse: collapse; padding: 2px; margin-bottom: 0; border: 0; background: transparent; }
table.CodeRay td { padding: 0 .5em; vertical-align: top; }
table.CodeRay td.line-numbers { text-align: right; color: #999; border-right: 1px solid #e5e5e5; padding-left: 0; }
span.line-numbers { border-right: 1px solid #E5E5E5; color: #999; display: inline-block; margin-right: 0.5em; padding-right: 0.5em; }
.CodeRay td.line-numbers strong, .CodeRay span.line-numbers strong { font-weight: normal; }
.CodeRay .debug { color: white !important; background: blue !important; }
.CodeRay .annotation { color: #007; }
.CodeRay .attribute-name { color: #f08; }
.CodeRay .attribute-value { color: #700; }
.CodeRay .binary { color: #509; }
.CodeRay .comment  { color: #999; font-style: italic; }
.CodeRay .char { color: #04D; }
.CodeRay .char .content { color: #04D; }
.CodeRay .char .delimiter { color: #039; }
.CodeRay .class { color: #458; }
.CodeRay .complex { color: #A08; }
.CodeRay .constant { color: teal; }
.CodeRay .color { color: #0A0; }
.CodeRay .class-variable { color: #369; }
.CodeRay .decorator { color: #B0B; }
.CodeRay .definition { color: #099; }
.CodeRay .directive { color: #088; }
.CodeRay .delimiter { color: black; }
.CodeRay .doc { color: #970; }
.CodeRay .doctype { color: #34b; }
.CodeRay .doc-string { color: #D42; }
.CodeRay .escape  { color: #666; }
.CodeRay .entity { color: #800; }
.CodeRay .error { color: #808; }
.CodeRay .exception { color: #C00; }
.CodeRay .filename { color: #099; }
.CodeRay .function { color: #900; }
.CodeRay .global-variable { color: teal; }
.CodeRay .hex { color: #058; }
.CodeRay .integer  { color: #099; }
.CodeRay .include { color: #B44; }
.CodeRay .inline { color: black; }
.CodeRay .inline .inline { background: #ccc; }
.CodeRay .inline .inline .inline { background: #bbb; }
.CodeRay .inline .inline-delimiter { color: #D14; }
.CodeRay .inline-delimiter { color: #D14; }
.CodeRay .important { color: #f00; }
.CodeRay .interpreted { color: #B2B; }
.CodeRay .instance-variable { color: teal; }
.CodeRay .label { color: #970; }
.CodeRay .local-variable { color: #963; }
.CodeRay .octal { color: #40E; }
.CodeRay .predefined { color: #369; }
.CodeRay .preprocessor { color: #579; }
.CodeRay .pseudo-class { color: #00C; }
.CodeRay .predefined-type { color: #074; }
.CodeRay .reserved, .keyword  { color: #000; }
.CodeRay .key { color: #808; }
.CodeRay .key .delimiter { color: #606; }
.CodeRay .key .char { color: #80f; }
.CodeRay .value { color: #088; }
.CodeRay .regexp { background-color: #fff0ff; }
.CodeRay .regexp .content { color: #808; }
.CodeRay .regexp .delimiter { color: #404; }
.CodeRay .regexp .modifier { color: #C2C; }
.CodeRay .regexp .function  { color: #404; font-weight: bold; }
.CodeRay .string { color: #D20; }
.CodeRay .string .string { }
.CodeRay .string .string .string { background-color: #ffd0d0; }
.CodeRay .string .content { color: #D14; }
.CodeRay .string .char { color: #D14; }
.CodeRay .string .delimiter { color: #D14; }
.CodeRay .shell { color: #D14; }
.CodeRay .shell .content { }
.CodeRay .shell .delimiter { color: #D14; }
.CodeRay .symbol { color: #990073; }
.CodeRay .symbol .content { color: #A60; }
.CodeRay .symbol .delimiter { color: #630; }
.CodeRay .tag, .CodeRay .attribute-name { color: #070; }
.CodeRay .tag-special { color: #D70; }
.CodeRay .type { color: #339; }
.CodeRay .variable  { color: #036; }
.CodeRay .insert { background: #afa; }
.CodeRay .delete { background: #faa; }
.CodeRay .change { color: #aaf; background: #007; }
.CodeRay .head { color: #f8f; background: #505; }
.CodeRay .insert .insert { color: #080; }
.CodeRay .delete .delete { color: #800; }
.CodeRay .change .change { color: #66f; }
.CodeRay .head .head { color: #f4f; }

</style> </head> <body class="book"> <div id="header"> </div> <div id="content"> <div class="sect1"> <h2 id="_clustering_modes"><a class="anchor" href="#_clustering_modes"></a>1. Clustering modes</h2> <div class="sectionbody"> <div class="paragraph"> <p>Infinispan can be configured to be either local (standalone) or clustered. If in a cluster, the cache can be configured to replicate changes to all nodes, to invalidate changes across nodes and finally to be used in distributed mode - state changes are replicated to a small subset of nodes enough to be fault tolerant but not too many nodes to prevent scalability.</p> </div> <div class="sect2"> <h3 id="_local_mode"><a class="anchor" href="#_local_mode"></a>1.1. Local Mode</h3> <div class="paragraph"> <p>While Infinispan is particularly interesting in clustered mode, it also offers a very capable local mode. In this mode, it acts as a simple, in-memory data cache similar to JBoss Cache and EHCache.</p> </div> <div class="paragraph"> <p>But why would one use a local cache rather than a map? Caches offer a lot of features over and above a simple map, including write-through and write-behind caching to persist data, eviction of entries to prevent running out of memory, and support for expirable entries. Infinispan, specifically, is built around a high-performance, read-biased data container which uses modern techniques similar to <a href="http://en.wikipedia.org/wiki/Read-copy-update">read-copy-update</a>&#8201;&#8212;&#8201;which buys you non-blocking, thread-safe reads even when concurrent writes are taking place. Infinispan also makes heavy use of compare-and-swap and other lock-free algorithms, making it ideal for high-throughput, multi-CPU/multi-core environments. Further, Infinispan&#8217;s Cache API extends the JDK&#8217;s ConcurrentMap - making migration from a map to Infinispan trivial.</p> </div> </div> <div class="sect2"> <h3 id="_replicated_mode"><a class="anchor" href="#_replicated_mode"></a>1.2. Replicated Mode</h3> <div class="paragraph"> <p>Replication is a simple clustered mode where cache instances automatically discover neighboring instances on other JVMs on the same local network, and form a cluster. Entries added to any of these cache instances will be replicated to all other cache instances in the cluster, and can be retrieved locally from any instance. This clustered mode provides a quick and easy way to share state across a cluster, however replication practically only performs well in small clusters (under 10 nodes), due to the number of replication messages that need to happen - as the cluster size increases. Infinispan can be configured to use UDP multicast which mitigates this problem to some degree.</p> </div> <div class="imageblock"> <div class="content"> <img src="images/Figure1_6.png" alt="Figure1 6"> </div> <div class="title">Figure 1. Replication mode</div> </div> <div class="paragraph"> <p>Replication can be synchronous or asynchronous. Use of either one of the options is application dependent. Synchronous replication blocks the caller (e.g. on a put() ) until the modifications have been replicated successfully to all nodes in a cluster. Asynchronous replication performs replication in the background (the put() returns immediately). Infinispan offers a replication queue, where modifications are replicated periodically (i.e. interval-based), or when the queue size exceeds a number of elements, or a combination thereof. A replication queue can therefore offer much higher performance as the actual replication is performed by a background thread.</p> </div> <div class="paragraph"> <p>Asynchronous replication is faster (no caller blocking), because synchronous replication requires acknowledgments from all nodes in a cluster that they received and applied the modification successfully (round-trip time). However, when a synchronous replication returns successfully, the caller knows for sure that all modifications have been applied to all cache instances, whereas this is not be the case with asynchronous replication. With asynchronous replication, errors are simply written to a log. Even when using transactions, a transaction may succeed but replication may not succeed on all cache instances.</p> </div> </div> <div class="sect2"> <h3 id="_invalidation_mode"><a class="anchor" href="#_invalidation_mode"></a>1.3. Invalidation Mode</h3> <div class="paragraph"> <p>Invalidation is a clustered mode that does not actually share any data at all, but simply aims to remove data that may be stale from remote caches. This cache mode only makes sense if you have another, permanent store for your data such as a database and are only using Infinispan as an optimization in a read-heavy system, to prevent hitting the database every time you need some state. If a cache is configured for invalidation rather than replication, every time data is changed in a cache other caches in the cluster receive a message informing them that their data is now stale and should be evicted from memory.</p> </div> <div class="imageblock"> <div class="content"> <img src="images/Figure2_5.png" alt="Figure2 5"> </div> <div class="title">Figure 2. Invalidation mode</div> </div> <div class="paragraph"> <p>Invalidation, when used with a shared cache loader would cause remote caches to refer to the shared cache loader to retrieve modified data. The benefit of this is twofold: network traffic is minimized as invalidation messages are very small compared to replicating updated data, and also that other caches in the cluster look up modified data in a lazy manner, only when needed.</p> </div> <div class="paragraph"> <p>Invalidation messages are sent after each modification (no transactions or batches), or at the end of a transaction or batch, upon successful commit. This is usually more efficient as invalidation messages can be optimized for the transaction as a whole rather than on a per-modification basis.</p> </div> <div class="paragraph"> <p>Invalidation too can be synchronous or asynchronous, and just as in the case of replication, synchronous invalidation blocks until all caches in the cluster receive invalidation messages and have evicted stale data while asynchronous invalidation works in a <em>fire-and-forget</em> mode, where invalidation messages are broadcast but doesn&#8217;t block and wait for responses.</p> </div> </div> <div class="sect2"> <h3 id="_distribution_mode"><a class="anchor" href="#_distribution_mode"></a>1.4. Distribution Mode</h3> <div class="paragraph"> <p>Distribution is a powerful clustering mode which allows Infinispan to scale linearly as more nodes are added to the cluster. Distribution makes use of a hash algorithm to determine on which node(s) entries should be stored. The number of copies that should be maintained in the cluster for each cache entry is configurable (<strong>numOwners</strong>). The number of copies represents the trade-off between performance and durability of data. The more copies you maintain, the lower performance will be, but also the lower the risk of losing data due to server outages. Regardless of how many copies are maintained, distribution still scales linearly and this is key to Infinispan&#8217;s scalability.</p> </div> <div class="paragraph"> <p>Another feature of the hash algorithm is that it is deterministic in locating entries without resorting to multicast requests or maintaining expensive metadata. Doing a GET anywhere will result in at most <em>numOwners</em> remote calls. In fact, the remote GET requests are done in parallel, and as soon as any one of these returns, the entry is passed back to the caller. A GET may also result in 0 remote calls if the key is present in the local cache. Doing a PUT can result in more remote calls, depending on the cache configuration (e.g. whether the cache is transactional).</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="icon-note" title="Note"></i> </td> <td class="content"> We are investigating doing a single GET request and contacting the other owners only after a timeout. See <a href="https://issues.jboss.org/browse/ISPN-825">ISPN-825</a>. </td> </tr> </table> </div> <div class="sect3"> <h4 id="_read_consistency"><a class="anchor" href="#_read_consistency"></a>1.4.1. Read consistency</h4> <div class="paragraph"> <p>Since GETs are sent to all data owners in parallel and the first returning result is used, this can lead to data inconsistency when using an <em>asynchronous</em> transport. If an updating thread modifies the primary data owner, but updates are only sent to backup nodes asynchronously, a concurrent read from the same thread may read a stale value for a short period of time until the asynchronous replication completes.</p> </div> <div class="paragraph"> <p>Note that this is <em>only</em> if the transport is <em>asynchronous</em>. If using a <em>synchronous</em> transport this behavior is not exhibited.</p> </div> <div class="imageblock"> <div class="content"> <img src="images/Figure3_3.png" alt="Figure3 3"> </div> <div class="title">Figure 3. Distribution mode</div> </div> </div> <div class="sect3"> <h4 id="_hashing_algorithms"><a class="anchor" href="#_hashing_algorithms"></a>1.4.2. Hashing Algorithms</h4> <div class="paragraph"> <p>The hashing algorithm in Infinispan is based on <a href="http://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a>, and even though our implementation has diverged a bit, we still use the term <strong>consistent hash</strong>.</p> </div> <div class="paragraph"> <p>Unlike in consistent hashing, we split the key space into fixed <strong>segments</strong>. The number of segments is configurable (<strong>numSegments</strong>), and it cannot be changed without restarting the cluster. The mapping of keys to segments is also fixed&#8201;&#8212;&#8201;a key should map to the same segment, regardless of how the topology of the cluster changes.</p> </div> <div class="paragraph"> <p>Each hash segment is mapped to a list of nodes called <strong>owners</strong>. The order matters, because the first owner, also known as the <strong>primary owner</strong>, has a special role in many cache operations (e.g. locking). The other owners are called <strong>backup owners</strong>. There is no hard rule on how the segments are mapped to owners, although the hashing algorithms generally try to balance the number of segments allocated to each node and at the same time minimize the number of segments that have to move after a node joins or leaves the cluster.</p> </div> <div class="paragraph"> <p>The hashing algorithm in Infinispan is customizable, and in fact there are five implementations that ship with Infinispan by default:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">org.infinispan.distribution.ch.DefaultConsistentHashFactory</dt> <dd> <p>The default hashing algorithm. It achieves a pretty even distribution, but it has one disadvantage: the mapping of segments to nodes depends on the order in which caches joined the cluster, so a key&#8217;s owners are not guaranteed to be the same in all the caches running in a cluster.</p> </dd> <dt class="hdlist1">org.infinispan.distribution.ch.TopologyAwareConsistentHashFactory</dt> <dd> <p>Selected automatically when <a href="#ServerHinting">Server Hinting</a> is enabled. Similar to the default algorithm, but also tries to spread each segment&#8217;s copies across as many sites, racks, or machines as possible.</p> </dd> <dt class="hdlist1">org.infinispan.distribution.ch.SyncConsistentHashFactory</dt> <dd> <p>An alternative algorithm, closer to consistent hashing (but still not exactly the same). It addresses the weakness of the default algorithm, and always assigns a key to the same node in every cache as long as the cluster is symmetric. It does have some weaknesses of itself, though: the load distribution is less even, and it also moves more segments than necessary on a join or leave.</p> </dd> <dt class="hdlist1">org.infinispan.distribution.ch.TopologyAwareSyncConsistentHashFactory</dt> <dd> <p>Similar to <em>SyncConsistentHashFactory</em>, but adapted for <a href="#ServerHinting">Server Hinting</a>.</p> </dd> <dt class="hdlist1">org.infinispan.distribution.ch.ReplicatedConsistentHashFactory</dt> <dd> <p>This algorithm is used internally to implement replicated caches. Users should never select this explicitly in a distributed cache.</p> </dd> </dl> </div> <div class="sect4"> <h5 id="_capacity_factors"><a class="anchor" href="#_capacity_factors"></a>Capacity Factors</h5> <div class="paragraph"> <p>The nodes in a cluster are not always identical. It is possible to have "non-standard" nodes that take <em>2x</em> as much load as a regular node, or <em>0.5x</em> as much load as a regular node, using the <strong>capacityFactor</strong> setting. The capacity factor can be any non-negative number, and the hashing algorithm will try to assign to each node a load weighted by its capacity factor (both as a primary owner and as a backup owner).</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="icon-note" title="Note"></i> </td> <td class="content"> Capacity factors support is new in Infinispan 6.0. </td> </tr> </table> </div> <div class="paragraph"> <p>One interesting use case is nodes with a capacity factor of <em>0</em>. This could be useful when some nodes are too short-lived to be useful as data owners, but they can&#8217;t use HotRod (or other remote protocols) because they need transactions. With cross-site replication as well, the "site master" should only deal with forwarding commands between sites and shouldn&#8217;t handle user requests, so it makes sense to configure it with a capacity factor of 0.</p> </div> </div> <div class="sect4"> <h5 id="_hashing_configuration"><a class="anchor" href="#_hashing_configuration"></a>Hashing Configuration</h5> <div class="paragraph"> <p>This is how you configure hashing declaratively, via XML:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="xml language-xml">   <span class="tag">&lt;namedCache</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">distributedCache</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
      <span class="tag">&lt;clustering</span> <span class="attribute-name">mode</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dist</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
         <span class="tag">&lt;hash</span> <span class="attribute-name">numOwners</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">numSegments</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">100</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">capacityFactor</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>
            <span class="attribute-name">factory</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.infinispan.distribution.ch.SyncConsistentHashFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
      <span class="tag">&lt;/clustering&gt;</span>
   <span class="tag">&lt;/namedCache&gt;</span></code></pre> </div> </div> <div class="paragraph"> <p>And this is how you can configure it programmatically, in Java:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="java language-java"><span class="predefined-type">Configuration</span> c = <span class="keyword">new</span> ConfigurationBuilder()
   .clustering()
      .cacheMode(CacheMode.DIST_SYNC)
      .hash()
         .numOwners(<span class="integer">2</span>)
         .numSegments(<span class="integer">100</span>)
         .capacityFactor(<span class="integer">2</span>)
         .consistentHashFactory(<span class="keyword">new</span> SyncConsistentHashFactory())
   .build();</code></pre> </div> </div> </div> </div> <div class="sect3"> <h4 id="_l1_caching"><a class="anchor" href="#_l1_caching"></a>1.4.3. L1 Caching</h4> <div class="paragraph"> <p>To prevent repeated remote calls when doing multiple GETs, L1 caching can be enabled. L1 caching places remotely received values in a near cache for a short period of time (configurable) so repeated lookups would not result in remote calls. In the above diagram, if L1 was enabled, a subsequent GET for the same key on Server3 would not result in any remote calls.</p> </div> <div class="imageblock"> <div class="content"> <img src="images/Figure4_4.png" alt="Figure4 4"> </div> <div class="title">Figure 4. L1 caching</div> </div> <div class="paragraph"> <p>L1 caching is not free though. Enabling it comes at a cost, and this cost is that every time a key is updated, an invalidation message needs to be multicast to ensure nodes with the entry in L1 invalidates the entry. L1 caching causes the requesting node to cache the retrieved entry locally and listen for changes to the key on the wire. L1-cached entries are given an internal expiry to control memory usage. Enabling L1 will improve performance for repeated reads of non-local keys, but will increase memory consumption to some degree. It offers a nice tradeoff between the "read-mostly" performance of an invalidated data grid with the scalability of a distributed one. Is L1 caching right for you? The correct approach is to benchmark your application with and without L1 enabled and see what works best for your access pattern.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon"> <i class="icon-tip" title="Tip"></i> </td> <td class="content"> Looking for Buddy Replication?  Buddy Replication - from JBoss Cache - does not exist in Infinispan.  See this blog article which discusses the reasons why Buddy Replication was not implemented in Infinispan, and how the same effects can be achieved using Infinispan: <a href="http://infinispan.blogspot.com/2009/08/distribution-instead-of-buddy.html">http://infinispan.blogspot.com/2009/08/distribution-instead-of-buddy.html</a> </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="ServerHinting"><a class="anchor" href="#ServerHinting"></a>1.4.4. Server Hinting</h4> <div class="paragraph"> <p>The motivations behind this feature is to ensure when using distribution, backups are not picked to reside on the same physical server, rack or data centre. For obvious reasons it doesn&#8217;t work with total replication.</p> </div> <div class="sect4"> <h5 id="_configuration"><a class="anchor" href="#_configuration"></a>Configuration</h5> <div class="paragraph"> <p>The hints are configured at transport level:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="xml language-xml"><span class="tag">&lt;transport</span>
    <span class="attribute-name">clusterName</span> = <span class="string"><span class="delimiter">&quot;</span><span class="content">MyCluster</span><span class="delimiter">&quot;</span></span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="attribute-name">machineId</span> = <span class="string"><span class="delimiter">&quot;</span><span class="content">LinuxServer01</span><span class="delimiter">&quot;</span></span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="attribute-name">rackId</span> = <span class="string"><span class="delimiter">&quot;</span><span class="content">Rack01</span><span class="delimiter">&quot;</span></span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="attribute-name">siteId</span> = <span class="string"><span class="delimiter">&quot;</span><span class="content">US-WestCoast</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre> </div> </div> <div class="paragraph"> <p>The following topology hints can be specified:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">machineId</dt> <dd> <p>This is probably the most useful, to disambiguate between multiple JVM instances on the same node, or even multiple virtual hosts on the same physical host.</p> </dd> <dt class="hdlist1">rackId</dt> <dd> <p>In larger clusters with nodes occupying more than a single rack, this setting would help prevent backups being stored on the same rack.</p> </dd> <dt class="hdlist1">siteId</dt> <dd> <p>To differentiate between nodes in different data centres replicating to each other. Note that <a href="#CrossSiteReplication">Cross site replication</a> is another alternative for clusters that need to span two or more data centres.</p> </dd> </dl> </div> <div class="paragraph"> <p>All of the above are optional, and if not provided, the distribution algorithms provide no guarantees that backups will not be stored in instances on the same machine/rack/site.</p> </div> </div> </div> <div class="sect3"> <h4 id="KeyAffinityService"><a class="anchor" href="#KeyAffinityService"></a>1.4.5. Key affinity service</h4> <div class="paragraph"> <p>The key affinity service solves the following problem: for a distributed Infinispan cluster one wants to make sure that a value is placed in a certain node. Based on a supplied cluster <a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/remoting/transport/Address.html">address</a> identifying the node, the service returns a key that will be hashed to that particular node.</p> </div> <div class="sect4"> <h5 id="_api"><a class="anchor" href="#_api"></a>API</h5> <div class="paragraph"> <p>Following code snippet depicts how a reference to this service can be obtained and used.</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="java language-java"><span class="comment">// 1. Obtain a reference to a cache manager</span>
EmbeddedCacheManager cacheManager = getCacheManager();<span class="comment">//obtain a reference to a cache manager</span>
Cache cache = cacheManager.getCache();
<span class="error"> </span>
<span class="comment">// 2. Create the affinity service</span>
KeyAffinityService keyAffinityService = KeyAffinityServiceFactory.newLocalKeyAffinityService(
      cache,
      <span class="keyword">new</span> RndKeyGenerator(),
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="predefined-type">Executors</span>.newSingleThreadExecutor(),
      <span class="integer">100</span>);
<span class="error"> </span>
<span class="comment">// 3. Obtain a key to be mapped to a certain address</span>
<span class="predefined-type">Object</span> localKey = keyAffinityService.getKeyForAddress(cacheManager.getAddress());
<span class="error"> </span>
<span class="comment">// 4. This put makes sure that the key resigns on the local node (as obtained cacheManager.getAddress())</span>
cache.put(localKey, <span class="string"><span class="delimiter">&quot;</span><span class="content">yourValue</span><span class="delimiter">&quot;</span></span>);</code></pre> </div> </div> <div class="paragraph"> <p>The service is started at step 2: after this point it uses the supplied <em>Executor</em> to generate and queue keys. At step 3, we obtain a key for this service, and use it at step 4, with that guarantee that it is distributed on the node identified by <code>cacheManager.getAddress()</code>.</p> </div> </div> <div class="sect4"> <h5 id="_lifecycle"><a class="anchor" href="#_lifecycle"></a>Lifecycle</h5> <div class="paragraph"> <p><em>KeyAffinityService</em> extends <em>Lifecycle</em>, which allows stopping and (re)starting it:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Lifecycle</span> {
<span class="error"> </span><span class="error"> </span> <span class="type">void</span> start();
<span class="error"> </span><span class="error"> </span> <span class="type">void</span> stop();
}</code></pre> </div> </div> <div class="paragraph"> <p>The service is instantiated through <em>KeyAffinityServiceFactory</em>. All the factory methods have an <em>Executor</em> parameter, that is used for asynchronous key generation (so that it won&#8217;t happen in the caller&#8217;s thread). It is the user&#8217;s responsibility to handle the shutdown of this <em>Executor</em>.</p> </div> <div class="paragraph"> <p>The <em>KeyAffinityService</em>, once started, needs to be explicitly stopped. This stops the background key generation and releases other held resources.</p> </div> <div class="paragraph"> <p>The only situation in which <em>KeyAffinityService</em> stops by itself is when the cache manager with which it was registered is shutdown.</p> </div> </div> <div class="sect4"> <h5 id="_topology_changes"><a class="anchor" href="#_topology_changes"></a>Topology changes</h5> <div class="paragraph"> <p>When a topology change takes place the key ownership from the <em>KeyAffinityService</em> might change. The key affinity service keep tracks of these topology changes and updates and doesn&#8217;t return stale keys, i.e. keys that would currently map to a different node than the one specified. However, this does not guarantee that at the time the key is used its node affinity hasn&#8217;t changed, e.g.:</p> </div> <div class="ulist"> <ul> <li> <p>Thread <code>T1</code> reads a key <code>k1</code> that maps to node <code>A</code>.</p> </li> <li> <p>A topology change happens which makes <code>k1</code> map to node <code>B</code>.</p> </li> <li> <p><code>T1</code> uses <code>k1</code> to add something to the cache. At this point <code>k1</code> maps to <code>B</code>, a different node than the one requested at the time of read.</p> </li> </ul> </div> <div class="paragraph"> <p>Whilst this is not ideal, it should be a supported behaviour for the application as all the already in-use keys might be moved over during cluster change. The <em>KeyAffinityService</em> provides an access proximity optimisation for stable clusters which doesn&#8217;t apply during the instability of topology changes.</p> </div> </div> </div> <div class="sect3"> <h4 id="_the_grouping_api"><a class="anchor" href="#_the_grouping_api"></a>1.4.6. The Grouping API</h4> <div class="paragraph"> <p>Complementary to <a href="#KeyAffinityService">Key affinity service</a> and similar to <a href="https://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/atomic/AtomicMap.html">AtomicMap</a>, the grouping API allows you to co-locate a group of entries on the same nodes, but without being able to select the actual nodes.</p> </div> <div class="sect4"> <h5 id="_how_does_it_work"><a class="anchor" href="#_how_does_it_work"></a>How does it work?</h5> <div class="paragraph"> <p>Normally, when you store an entry, Infinispan will take a hash code of the key, map the hash to a hash segment, and store the entry on the nodes which own that segment. Infinispan always uses an algorithm to locate a key, never allowing the nodes on which the entry is stored to be specified manually. This scheme allows any node to know which nodes owns a key, without having to distribute such ownership information. This reduces the overhead of Infinispan, but more importantly improves redundancy as there is no need to replicate the ownership information in case of node failure.</p> </div> <div class="paragraph"> <p>If you use the grouping API, then Infinispan will ignore the hash of the key when deciding which <em>node</em> to store the entry on, and instead use a hash of the group. Infinispan still uses the hash of the key in its internal data structures, so using the grouping API will not slow things down. When the group API is in use, it is important that every node can still compute, using an algorithm, the owners of every key. For this reason, the group cannot be specified manually. The group can either be intrinsic to the entry (generated by the key class) or extrinsic (generated by an external function).</p> </div> </div> <div class="sect4"> <h5 id="_how_do_i_use_the_grouping_api"><a class="anchor" href="#_how_do_i_use_the_grouping_api"></a>How do I use the grouping API?</h5> <div class="paragraph"> <p>First, you must enable groups. If you are configuring Infinispan programmatically, then call:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="java language-java"><span class="predefined-type">Configuration</span> c = <span class="keyword">new</span> ConfigurationBuilder()
   .clustering().hash().groups().enabled()
   .build();</code></pre> </div> </div> <div class="paragraph"> <p>Or, if you are using XML:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="xml language-xml"><span class="tag">&lt;clustering&gt;</span>
   <span class="tag">&lt;hash&gt;</span>
      <span class="tag">&lt;groups</span> <span class="attribute-name">enabled</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
   <span class="tag">&lt;/hash&gt;</span>
<span class="tag">&lt;/clustering&gt;</span></code></pre> </div> </div> <div class="paragraph"> <p>If you have control of the key class (you can alter the class definition, it&#8217;s not part of an unmodifiable library), and the determination of the group is not an orthogonal concern to the key class, then we recommend you use an intrinsic group. The intrinsic group can be specified using the <em>@Group</em> annotation placed on the method. Let&#8217;s take a look at an example:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="java language-java"><span class="type">class</span> <span class="class">User</span> {
<span class="error"> </span><span class="error"> </span> ...
<span class="error"> </span><span class="error"> </span> <span class="predefined-type">String</span> office;
<span class="error"> </span><span class="error"> </span> ...

<span class="error"> </span><span class="error"> </span> <span class="directive">public</span> <span class="type">int</span> hashCode() {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="comment">// Defines the hash for the key, normally used to determine location</span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> ...
<span class="error"> </span><span class="error"> </span> }

<span class="error"> </span><span class="error"> </span> <span class="comment">// Override the location by specifying a group, all keys in the same</span>
<span class="error"> </span><span class="error"> </span> <span class="comment">// group end up with the same owner</span>
<span class="error"> </span><span class="error"> </span> <span class="annotation">@Group</span>
<span class="error"> </span><span class="error"> </span> <span class="directive">public</span> <span class="predefined-type">String</span> getOffice() {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">return</span> office;
<span class="error"> </span><span class="error"> </span> }
<span class="error"> </span><span class="error"> </span> }
}</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="icon-note" title="Note"></i> </td> <td class="content"> The group must be a <code>String</code> </td> </tr> </table> </div> <div class="paragraph"> <p>If you don&#8217;t have control over the key class, or the determination of the group is an orthogonal concern to the key class, we recommend you use an extrinsic group. An extrinsic group is specified by implementing the <em>Grouper</em> interface, which has a single method computeGroup, which should return the group. <em>Grouper</em> acts as an interceptor, passing the previously computed value in. The group passed to the first <em>Grouper</em> will be that determined by <em>@Group</em> (if <em>@Group</em> is defined). This allows you even greater control over the group when using an intrinsic group. For a grouper to be used when determining the group for a key, its <em>keyType</em> must be assignable from the key being grouped.</p> </div> <div class="paragraph"> <p>Let&#8217;s take a look at an example of a <em>Grouper</em>:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">KXGrouper</span> <span class="directive">implements</span> Grouper&lt;<span class="predefined-type">String</span>&gt; {

<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="comment">// A pattern that can extract from a &quot;kX&quot; (e.g. k1, k2) style key</span>
   <span class="comment">// The pattern requires a String key, of length 2, where the first character is</span>
   <span class="comment">// &quot;k&quot; and the second character is a digit. We take that digit, and perform</span>
   <span class="comment">// modular arithmetic on it to assign it to group &quot;1&quot; or group &quot;2&quot;.</span>
<span class="error"> </span><span class="error"> </span> <span class="directive">private</span> <span class="directive">static</span> <span class="predefined-type">Pattern</span> kPattern = <span class="predefined-type">Pattern</span>.compile(<span class="string"><span class="delimiter">&quot;</span><span class="content">(^k)(&lt;a&gt;</span><span class="char">\\</span><span class="content">d&lt;/a&gt;)$</span><span class="delimiter">&quot;</span></span>);

<span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="directive">public</span> <span class="predefined-type">String</span> computeGroup(<span class="predefined-type">String</span> key, <span class="predefined-type">String</span> group) {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="predefined-type">Matcher</span> matcher = kPattern.matcher(key);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">if</span> (matcher.matches()) {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="predefined-type">String</span> g = <span class="predefined-type">Integer</span>.parseInt(matcher.group(<span class="integer">2</span>)) % <span class="integer">2</span> + <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">return</span> g;
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> } <span class="keyword">else</span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">return</span> <span class="predefined-constant">null</span>;
<span class="error"> </span><span class="error"> </span><span class="error"> </span> }

<span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;<span class="predefined-type">String</span>&gt; getKeyType() {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">return</span> <span class="predefined-type">String</span>.class;
<span class="error"> </span><span class="error"> </span><span class="error"> </span> }
}</code></pre> </div> </div> <div class="paragraph"> <p>Here we determine a simple grouper that can take the key class and extract from the group from the key using a pattern. We ignore any group information specified on the key class.</p> </div> <div class="paragraph"> <p>You must register every grouper you wish to have used. If you are configuring Infinispan programmatically:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="java language-java"><span class="predefined-type">Configuration</span> c = <span class="keyword">new</span> ConfigurationBuilder()
   .clustering().hash().groups().enabled().addGrouper(<span class="keyword">new</span> KXGrouper())
   .build();</code></pre> </div> </div> <div class="paragraph"> <p>Or, if you are using XML:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="xml language-xml"><span class="tag">&lt;clustering&gt;</span>
  <span class="tag">&lt;hash&gt;</span>
     <span class="tag">&lt;groups</span> <span class="attribute-name">enabled</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;grouper</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.KXGrouper</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
     <span class="tag">&lt;/groups&gt;</span>
  <span class="tag">&lt;/hash&gt;</span>
<span class="tag">&lt;/clustering&gt;</span></code></pre> </div> </div> </div> </div> </div> <div class="sect2"> <h3 id="_asynchronous_options"><a class="anchor" href="#_asynchronous_options"></a>1.5. Asynchronous Options</h3> <div class="paragraph"> <p>When Infinispan instances are clustered, regardless of the cluster mode, data can be propagated to other nodes in a synchronous or asynchronous way. When synchronous, the sender waits for replies from the receivers and when asynchronous, the sender sends the data and does not wait for replies from other nodes in the cluster.</p> </div> <div class="paragraph"> <p>With asynchronous modes, speed is more important than consistency and this is particularly advantageous in use cases such as HTTP session replication with sticky sessions enabled. In these scenarios, data, or in this case a particular session, is always accessed on the same cluster node and only in case of failure is data accessed in a different node. This type of architectures allow consistency to be relaxed in favour of increased performance.</p> </div> <div class="paragraph"> <p>In order to choose the asynchronous configuration that best suits your application, it&#8217;s important to understand the following configuration settings:</p> </div> <div class="sect3"> <h4 id="_asynchronous_communications"><a class="anchor" href="#_asynchronous_communications"></a>1.5.1. Asynchronous Communications</h4> <div class="paragraph"> <p>Whenever you add <a href="http://docs.jboss.org/infinispan/6.0/configdocs/infinispan-config-6.0.html"><code>&lt;async /&gt;</code></a> element within <code>&lt;clustering /&gt;</code>, you&#8217;re telling the underlying JGroups layer in Infinispan to use asynchronous communication. What this means is that JGroups will send any replication/distribution/invalidation request to the wire but will not wait for a reply from the receiver.</p> </div> </div> <div class="sect3"> <h4 id="_asynchronous_marshalling"><a class="anchor" href="#_asynchronous_marshalling"></a>1.5.2. Asynchronous Marshalling</h4> <div class="paragraph"> <p>This is a configurable boolean property of <a href="http://docs.jboss.org/infinispan/6.0/configdocs/infinispan-config-6.0.html"><code>&lt;async /&gt;</code></a> element that indicates whether the actual call from Infinispan to the JGroups layer is done on a separate thread or not. When set to true, once Infinispan has figured out that a request needs to be sent to another node, it submits it to the async transport executor so that it can talk to the underlying JGroups layer.</p> </div> <div class="paragraph"> <p>With asynchronous marshalling, Infinispan requests can return back to the client quicker compared to when async marshalling is set to false. The downside though is that client requests can be reordered before they have reached the JGroups layer. In other words, JGroups provides ordering guarantees even for async messages but with async marshalling turned on, requests can reach the JGroups in a different order in which they&#8217;re called. This can effectively lead to data consistency issues in applications making multiple modifications on the same key/value pair. For example, with async marshalling turned on:</p> </div> <div class="paragraph"> <p>App calls:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="java language-java">cache.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">car</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bmw</span><span class="delimiter">&quot;</span></span>);
cache.remove(<span class="string"><span class="delimiter">&quot;</span><span class="content">car</span><span class="delimiter">&quot;</span></span>);
</code></pre> </div> </div> <div class="paragraph"> <p>Other nodes could receive these operations in this order:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay"><code class="java language-java">cache.remove(<span class="string"><span class="delimiter">&quot;</span><span class="content">car</span><span class="delimiter">&quot;</span></span>);
cache.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">car</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bmw</span><span class="delimiter">&quot;</span></span>);
</code></pre> </div> </div> <div class="paragraph"> <p>The end result is clearly different which is often not desirable. So, if your application makes multiple modifications on the same key, you should either: turn off asynchronous marshalling, or set <a href="http://docs.jboss.org/infinispan/6.0/configdocs/infinispan-config-6.0.html"><code>&lt;asyncTransportExecutor /&gt;</code></a> element&#8217;s maxThreads to 1. The first modification only applies to a particular named cache, whereas the second option affects all named caches in configuration file that are configured with async marshalling. It&#8217;s worth noting though that having this type of executor configured with a single thread would defeat its purpose adding unnecessary contention point. It&#8217;d be better to simply switch off async marshalling.</p> </div> <div class="paragraph"> <p>On the contrary, if your application only ever makes one modification per key/value pair and there&#8217;s no happens-before relationship between them, then async marshalling is a very valid optimization that can increase performance of your application without data consistency risks.</p> </div> <div class="paragraph"> <p>If you have async marshalling turned on and see exceptions related to java.util.concurrent.RejectedExecutionException, you should also consider switching off async marshalling.</p> </div> </div> <div class="sect3"> <h4 id="_replication_queue"><a class="anchor" href="#_replication_queue"></a>1.5.3. Replication Queue</h4> <div class="paragraph"> <p>The aim of the replication queue is to batch the individual cache operations and send them as one, as opposed to sending each cache operation individually. As a result, replication queue enabled configurations perform generally better compared to those that have it switched off because less RPC messages are sent, fewer envelopes are used&#8230;etc. The only real trade off to the replication queue is that the queue is flushed periodically (based on time or queue size) and hence it might take longer for the replication/distribution/invalidation to be realised across the cluster. When replication queue is turned off, data is placed directly on the wire and hence it takes less for data to arrive to other nodes.</p> </div> </div> <div class="sect3"> <h4 id="_asynchronous_api"><a class="anchor" href="#_asynchronous_api"></a>1.5.4. Asynchronous API</h4> <div class="paragraph"> <p>Finally, the <a href="#_asynchronous_api">Asynchronous API</a> can be used to emulate non-blocking APIs, whereby calls are handed over to a different thread and asynchronous API calls return to the client immediately. Similar to async marshalling, using this API can lead to reordering, so you should avoid calling modifying asynchronous methods on the same keys.</p> </div> </div> <div class="sect3"> <h4 id="_return_values"><a class="anchor" href="#_return_values"></a>1.5.5. Return Values</h4> <div class="paragraph"> <p>Regardless of the asynchronous option used, the return values of cache operations are reliable. If talking about return values of cache operations that return previous value, the correctness of these returns are guaranteed as well regardless of the clustering mode. With replication, the previous value is already available locally, and with distribution, regardless of whether it&#8217;s asynchronous or synchronous, Infinispan sends a synchronous request to get the previous value if not present locally. If on the other hand the asynchronous API is used, client code needs to get hold of the <a href="https://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/commons/util/concurrent/NotifyingFuture.html">NotifiyngFuture</a> returned by the async operation in order to be able to query the previous value.</p> </div> </div> </div> </div> </div> </div> <div id="footer"> <div id="footer-text"> Last updated 2014-01-10 16:33:56 UTC </div> </div> </body> </html>